
<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stylish Fast File Upload (Mobile)</title>
<style>
  /* Mobile-first clean UI */
  :root{
    --bg:#f0f2f5; --card:#fff; --accent:#5b6cff; --muted:#8b94a6;
    --success:#22c55e; --danger:#ff6b6b; --radius:16px;
  }
  *{box-sizing:border-box; font-family:Inter, system-ui, Arial; -webkit-tap-highlight-color:transparent}
  html,body{height:100%; margin:0; background:var(--bg); color:#222}
  .wrap{min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px}
  .card{
    width:100%; max-width:420px; background:linear-gradient(180deg,#fff,#fbfcff);
    border-radius:var(--radius); box-shadow:0 8px 30px rgba(20,30,60,0.08); padding:18px;
  }
  .header{display:flex; align-items:center; gap:12px}
  .logo{background:linear-gradient(135deg,var(--accent),#8a6bff); width:44px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-size:18px}
  h1{font-size:18px;margin:0}
  p.lead{margin:6px 0 14px;color:var(--muted);font-size:13px}
  .drop{
    border:2px dashed #e6e9f2; border-radius:12px; padding:18px; text-align:center; background:linear-gradient(180deg,rgba(91,108,255,0.03),transparent);
  }
  .btn{
    display:inline-block;padding:10px 14px;border-radius:10px;background:var(--accent);color:#fff;border:0;cursor:pointer;font-weight:600;margin-top:10px;
  }
  input[type=file]{display:none}
  .list{margin-top:14px; display:flex;flex-direction:column; gap:12px}
  .file-row{background:#fff;border-radius:10px;padding:12px;display:flex;gap:12px;align-items:center;box-shadow:0 4px 12px rgba(16,24,40,0.03)}
  .file-thumb{width:44px;height:44px;border-radius:8px;background:#f3f4f8;display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--muted)}
  .file-info{flex:1}
  .file-name{font-weight:600;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .file-meta{font-size:12px;color:var(--muted);margin-top:4px}
  .progress{height:8px;background:#f1f3f8;border-radius:999px;margin-top:10px;overflow:hidden}
  .bar{height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#7b9cff)}
  .controls{display:flex;gap:8px}
  .small{font-size:13px;padding:8px 10px;border-radius:8px;border:1px solid #e6e9f2;background:#fff;cursor:pointer}
  .status{font-size:13px}
  .completed{color:var(--success);font-weight:600}
  .error{color:var(--danger);font-weight:600}
  .muted{color:var(--muted)}
  .footer{margin-top:14px;text-align:center;font-size:12px;color:var(--muted)}
  @media(min-width:720px){ .card{max-width:640px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <div class="logo">UP</div>
      <div>
        <h1>Upload Files — Super Fast</h1>
        <p class="lead">Koi bhi format — images, videos, pdf, .exe, .zip — upto 5GB. Resume & chunked upload.</p>
      </div>
    </div>

    <div style="height:12px"></div>

    <label class="drop" id="dropzone">
      <div style="font-size:20px; color:var(--muted)">☁️</div>
      <div style="font-weight:600; margin-top:6px">Choose a file or drag & drop</div>
      <div class="muted" style="font-size:13px; margin-top:6px">All formats allowed • Max 5 GB</div>
      <button class="btn" id="browseBtn" type="button">Browse File</button>
      <input id="fileInput" type="file" />
    </label>

    <div class="list" id="fileList"></div>

    <div class="footer">Tip: Use good internet & server with plenty of bandwidth for fastest uploads.</div>
  </div>
</div>

<script>
/*
  Frontend chunked uploader (single file).
  How it works:
  - Splits file into chunks (default chunkSize = 5 MB)
  - Uploads chunks in parallel (concurrency = 3)
  - Tracks progress and retries failed chunks up to retryLimit
  - Supports basic resume: server should respond to /upload/status?fileId=... with already-received indexes
  - fileId is generated as sha1-ish from name+size+lastModified (simple hash)
*/

/* ---------- CONFIG ---------- */
const MAX_FILE_SIZE = 5 * 1024 * 1024 * 1024; // 5GB
let CHUNK_SIZE = 5 * 1024 * 1024; // 5MB default chunk size (adjustable)
const CONCURRENCY = 3; // parallel uploads
const RETRY_LIMIT = 3;

/* ---------- END CONFIG ---------- */

const fileInput = document.getElementById('fileInput');
const dropzone = document.getElementById('dropzone');
const browseBtn = document.getElementById('browseBtn');
const fileList = document.getElementById('fileList');

// server endpoints - change to your production endpoints
const UPLOAD_URL = '/upload';           // POST chunk
const STATUS_URL = '/upload/status';    // GET ?fileId=...
const COMPLETE_URL = '/upload/complete';// POST to finalize

// utility: simple hash -> not cryptographic but ok for id
function simpleHash(str){
  let h=2166136261>>>0;
  for(let i=0;i<str.length;i++){ h = Math.imul(h ^ str.charCodeAt(i), 16777619); }
  return (h>>>0).toString(36);
}

browseBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', e => handleFiles(e.target.files));
['dragenter','dragover'].forEach(ev => {
  dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.style.borderColor = '#d6dbff' });
});
['dragleave','drop'].forEach(ev => {
  dropzone.addEventListener(ev, e => { e.preventDefault(); dropzone.style.borderColor = '#e6e9f2'; });
});
dropzone.addEventListener('drop', e => {
  if(e.dataTransfer && e.dataTransfer.files) handleFiles(e.dataTransfer.files);
});

function handleFiles(files){
  if(!files || files.length===0) return;
  for(const f of files){
    if(f.size > MAX_FILE_SIZE){ alert('File exceeds 5GB limit'); continue; }
    createFileRow(f);
  }
}

function createFileRow(file){
  const id = simpleHash(file.name + '::' + file.size + '::' + file.lastModified);
  const row = document.createElement('div'); row.className = 'file-row';
  row.dataset.fileId = id;

  row.innerHTML = `
    <div class="file-thumb">${file.name.split('.').pop().slice(0,3).toUpperCase()}</div>
    <div class="file-info">
      <div class="file-name">${file.name}</div>
      <div class="file-meta muted">${(file.size/1024/1024).toFixed(2)} MB</div>
      <div class="progress"><div class="bar" style="width:0%"></div></div>
    </div>
    <div style="display:flex;flex-direction:column;align-items:flex-end">
      <div class="status muted">Queued</div>
      <div class="controls" style="margin-top:8px">
        <button class="small start">Start</button>
        <button class="small cancel">Cancel</button>
      </div>
    </div>
  `;

  fileList.prepend(row);

  const startBtn = row.querySelector('.start');
  const cancelBtn = row.querySelector('.cancel');
  const statusEl = row.querySelector('.status');
  const bar = row.querySelector('.bar');

  let controller = { abort:false };

  startBtn.addEventListener('click', ()=> {
    startBtn.disabled = true;
    statusEl.textContent = 'Preparing...';
    uploadFile(file, id, {
      onProgress: p => { bar.style.width = p + '%'; statusEl.textContent = `Uploading ${p.toFixed(1)}%`; },
      onComplete: () => { bar.style.width = '100%'; statusEl.textContent = 'Completed'; statusEl.className='status completed'; startBtn.style.display='none'; },
      onError: (err) => { statusEl.textContent = 'Error: ' + err; statusEl.className='status error'; startBtn.disabled = false; },
      signalObj: controller
    });
  });

  cancelBtn.addEventListener('click', ()=> {
    controller.abort = true;
    statusEl.textContent = 'Cancelled';
    statusEl.className='status muted';
    startBtn.disabled = false;
  });
}

/* ---------- Upload logic ---------- */
async function uploadFile(file, fileId, opts){
  opts = opts || {};
  const totalSize = file.size;
  // dynamic chunk sizing for super large files: increase chunk size if file big
  let chunkSize = CHUNK_SIZE;
  if(totalSize > 500 * 1024 * 1024) chunkSize = 10 * 1024 * 1024; // 10MB for >500MB
  if(totalSize > 2 * 1024 * 1024 * 1024) chunkSize = 20 * 1024 * 1024; // 20MB for >2GB

  const totalChunks = Math.ceil(totalSize / chunkSize);

  // ask server which chunks already present (for resume)
  let uploadedSet = new Set();
  try {
    const qs = new URLSearchParams({ fileId, fileName: file.name, fileSize: totalSize });
    const res = await fetch(STATUS_URL + '?' + qs.toString());
    if(res.ok){
      const json = await res.json();
      if(Array.isArray(json.received)) json.received.forEach(i => uploadedSet.add(i));
    }
  } catch(e){
    // ignore - server might not support status
  }

  let uploadedBytes = 0;
  // compute already uploaded bytes
  uploadedSet.forEach(i => {
    const end = Math.min((i+1)*chunkSize, totalSize);
    uploadedBytes += (end - i*chunkSize);
  });

  const onProgress = opts.onProgress || function(){};
  const signalObj = opts.signalObj || { abort:false };

  // prepare queue of chunk indexes to upload
  const queue = [];
  for(let i=0;i<totalChunks;i++){
    if(!uploadedSet.has(i)) queue.push(i);
  }

  let active = 0;
  let idxPointer = 0;
  let retries = {};

  return new Promise((resolve, reject) => {
    function next(){
      if(signalObj.abort){ reject('aborted'); return; }
      if(uploadedBytes >= totalSize){
        // finalize
        finalizeUpload().then(()=>{ onProgress(100); resolve(); }).catch(err=>reject(err));
        return;
      }
      while(active < CONCURRENCY && idxPointer < queue.length){
        const chunkIndex = queue[idxPointer++];
        active++;
        sendChunkWithRetry(chunkIndex).then(bytesSent=>{
          active--;
          uploadedBytes += bytesSent;
          onProgress((uploadedBytes/totalSize)*100);
          if(uploadedBytes >= totalSize){
            next();
          } else {
            next();
          }
        }).catch(err=>{
          active--;
          reject(err);
        });
      }
      // if no active and pointer done but uploadedBytes < totalSize -> means waiting for finalize or something
      if(active === 0 && idxPointer >= queue.length && uploadedBytes < totalSize){
        // maybe some pending chunks errored out and retries exhausted
        // wait briefly
        setTimeout(()=>{ if(active===0 && uploadedBytes < totalSize) reject('Failed to upload some chunks'); }, 2000);
      }
    }

    async function sendChunkWithRetry(i){
      let attempts = retries[i] || 0;
      while(attempts < RETRY_LIMIT){
        try {
          const sent = await sendChunk(i);
          return sent;
        } catch(e){
          attempts++;
          retries[i] = attempts;
          console.warn('Chunk', i, 'failed attempt', attempts, e);
          await new Promise(r => setTimeout(r, 500 * attempts));
        }
      }
      throw('Chunk ' + i + ' failed after retries');
    }

    async function sendChunk(i){
      if(signalObj.abort) throw('aborted');
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, totalSize);
      const blob = file.slice(start, end);
      // upload via fetch
      const form = new FormData();
      form.append('chunk', blob);
      form.append('fileId', fileId);
      form.append('fileName', file.name);
      form.append('chunkIndex', i);
      form.append('totalChunks', totalChunks);

      const resp = await fetch(UPLOAD_URL, {
        method:'POST',
        body: form,
      });
      if(!resp.ok) {
        const text = await resp.text().catch(()=>resp.statusText);
        throw(text || 'Upload chunk failed');
      }
      // assume server returns JSON { ok:true }
      return (end - start);
    }

    async function finalizeUpload(){
      // tell server to assemble
      const resp = await fetch(COMPLETE_URL, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ fileId, fileName: file.name, fileSize: totalSize })
      });
      if(!resp.ok) throw('Finalize error');
      return await resp.json();
    }

    // start initial workers
    next();
  });
}
</script>
</body>
</html>
